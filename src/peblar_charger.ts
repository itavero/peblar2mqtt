import createClient, {MiddlewareOnRequest, type Client} from 'openapi-fetch';
import type {paths} from './generated/api/v1'; // generated by openapi-typescript
import {getVersion} from './util/version';

// Constants for "dynamic" timer intervals
const INTERVAL_CHECK_HEALTH_ONLINE = 1000 * 60 * 60; // 1 hour
const INTERVAL_CHECK_HEALTH_OFFLINE = 1000 * 10; // 10 seconds
const INTERVAL_CHECK_SYSTEM = 1000 * 60 * 1; // 1 hour
const INTERVAL_CHECK_METER_CHARGING = 1000 * 10; // 5 seconds
const INTERVAL_CHECK_METER_IDLE = 1000 * 60 * 5; // 5 minutes
const INTERVAL_CHECK_EV_INTERFACE_CHARGING = 1000 * 10; // 5 seconds
const INTERVAL_CHECK_EV_INTERFACE_IDLE = 1000 * 30; // 30 seconds

// Availability constants
const AVAILABLE_ONLINE = 'online';
const AVAILABLE_OFFLINE = 'offline';

class ApiTokenMiddleware {
  private token_: string;

  constructor(token: string) {
    this.token_ = token;
  }

  onRequest: MiddlewareOnRequest = ({request}) => {
    const headers = new Headers(request.headers);
    headers.set('Authorization', this.token_);
    return new Request(request, {headers});
  };
}

export interface MqttEndpoint {
  publishData(subject: string, data: string, retain?: boolean): void;
  publishHomeAssistantDiscoveryConfig(
    type: string,
    name: string,
    config: unknown
  ): void;
  getFullDataTopicPath(subject: string): string;
  getBridgeAvailabilityTopicPath(): string;
}

class HomeAssistantDeviceInfo {
  private identifiers_: Set<string>;
  private readonly manufacturer_: string;
  private model_: string;
  private readonly name_: string;
  private sw_version_: string;
  private serial_number_: string;
  private did_change_ = false;

  constructor(
    identifiers: string[],
    manufacturer: string,
    model: string,
    name: string,
    sw_version?: string,
    serial_number?: string
  ) {
    this.identifiers_ = new Set(identifiers);
    this.manufacturer_ = manufacturer;
    this.model_ = model;
    this.name_ = name;
    this.sw_version_ = sw_version ?? '';
    this.serial_number_ = serial_number ?? '';
  }

  equals(other: HomeAssistantDeviceInfo): boolean {
    return (
      this.manufacturer_ === other.manufacturer_ &&
      this.model_ === other.model_ &&
      this.name_ === other.name_ &&
      this.sw_version_ === other.sw_version_ &&
      this.identifiers_.size === other.identifiers_.size &&
      Array.from(this.identifiers_).every(id => other.identifiers_.has(id))
    );
  }

  get identifiers(): string[] {
    return Array.from(this.identifiers_);
  }

  get manufacturer(): string {
    return this.manufacturer_;
  }

  set serialNumber(serial_number: string) {
    if (this.serial_number_ !== serial_number) {
      this.serial_number_ = serial_number;
      this.identifiers_.add(serial_number);
      this.did_change_ = true;
    }
  }

  get model(): string {
    return this.model_;
  }

  set model(model: string) {
    if (this.model_ !== model) {
      this.model_ = model;
      this.did_change_ = true;
    }
  }

  get name(): string {
    return this.name_;
  }

  get sw_version(): string {
    return this.sw_version_;
  }

  set sw_version(sw_version: string) {
    if (this.sw_version_ !== sw_version) {
      this.sw_version_ = sw_version;
      this.did_change_ = true;
    }
  }

  get has_changed(): boolean {
    return this.did_change_;
  }

  addIdentifier(identifier: string): void {
    if (!this.identifiers_.has(identifier)) {
      this.identifiers_.add(identifier);
      this.did_change_ = true;
    }
  }

  resetChangeFlag(): void {
    this.did_change_ = false;
  }

  toPlainObject(): Record<string, unknown> {
    return {
      identifiers: this.identifiers,
      manufacturer: this.manufacturer_,
      model: this.model_,
      name: this.name_,
      sw_version: this.sw_version_,
    };
  }
}

export class ChargerMonitor {
  private mqtt_: MqttEndpoint;
  private name_: string;
  private host_: string;
  private password_: string | undefined;
  private client_: Client<paths>;

  // Timers
  private timer_health_check_: NodeJS.Timeout | undefined;
  private timer_system_update_: NodeJS.Timeout | undefined;
  private timer_meter_update_: NodeJS.Timeout | undefined;
  private timer_ev_interface_update_: NodeJS.Timeout | undefined;

  // Charger state and such
  private is_online_ = false;
  private has_write_access_ = false;
  private api_version_: string | undefined;
  private has_car_connected_ = false;
  private phase_count_ = 1;
  private allow_single_phase_ = false;

  // Home Assistant device info:
  private device_info_: HomeAssistantDeviceInfo;

  constructor(
    mqtt: MqttEndpoint,
    name: string,
    host: string,
    api_key: string,
    password?: string
  ) {
    this.mqtt_ = mqtt;
    this.name_ = name;
    this.host_ = host;
    this.password_ = password;

    // Update device_info_
    this.device_info_ = new HomeAssistantDeviceInfo(
      [name],
      'Peblar',
      '',
      name,
      ''
    );
    // Create REST API client from generated Open API models
    this.client_ = createClient<paths>({
      baseUrl: `http://${this.host_}/api/wlac/v1`,
    });
    this.client_.use(new ApiTokenMiddleware(api_key));
  }

  get name(): string {
    return this.name_;
  }

  async start(): Promise<void> {
    // Always start with a health check
    this.checkIfOnline();
  }

  stop(): void {
    // Stop all timers for this charger
    if (this.timer_health_check_) {
      clearTimeout(this.timer_health_check_);
    }
    if (this.timer_system_update_) {
      clearTimeout(this.timer_system_update_);
    }
    if (this.timer_meter_update_) {
      clearTimeout(this.timer_meter_update_);
    }
    if (this.timer_ev_interface_update_) {
      clearTimeout(this.timer_ev_interface_update_);
    }
  }

  async checkIfOnline(): Promise<void> {
    // Check if the charger is online
    const {data, error} = await this.client_.GET('/health');
    const previous_online = this.is_online_;
    if (error) {
      // Assume offline
      console.error('Error checking health:', error);
      this.is_online_ = false;
      this.mqtt_.publishData('available', AVAILABLE_OFFLINE, true);
    } else {
      console.log(data);
      this.is_online_ = true;
      this.api_version_ = data.ApiVersion;
      this.has_write_access_ = data.AccessMode === 'ReadWrite';
      this.mqtt_.publishData('available', AVAILABLE_ONLINE, true);
      this.mqtt_.publishData('health', JSON.stringify(data));

      // Check if online status changed
      if (previous_online !== this.is_online_) {
        // Trigger other checks
        this.getSystemData();
        this.getMeterData();
        this.getEvInterfaceData();
      }
    }
    if (this.timer_health_check_) {
      clearTimeout(this.timer_health_check_);
    }
    this.timer_health_check_ = setTimeout(
      this.checkIfOnline.bind(this),
      this.is_online_
        ? INTERVAL_CHECK_HEALTH_ONLINE
        : INTERVAL_CHECK_HEALTH_OFFLINE
    );
  }

  async publishHomeAssistantDeviceInfo(): Promise<void> {
    const device = this.device_info_.toPlainObject();
    const origin = {
      name: 'Peblar2MQTT',
      sw_version: getVersion(),
      support_url: 'https://github.com/itavero/peblar2mqtt',
    };
    const availability = [
      {
        topic: this.mqtt_.getBridgeAvailabilityTopicPath(),
      },
      {
        topic: this.mqtt_.getFullDataTopicPath('available'),
      },
    ];
    this.device_info_.resetChangeFlag();

    // Sensor: Energy Total
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'energy_total', {
      object_id: `${this.name_}_energy_total`,
      unique_id: `${this.name_}_energy_total_p2m`,
      name: 'Energy Total',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.EnergyTotal }}',
      unit_of_measurement: 'Wh',
      device_class: 'energy',
      state_class: 'total_increasing',
      device: device,
      origin: origin,
    });

    // Sensor: Energy Session
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'energy_session', {
      object_id: `${this.name_}_energy_session`,
      unique_id: `${this.name_}_energy_session_p2m`,
      name: 'Energy Session',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.EnergySession }}',
      unit_of_measurement: 'Wh',
      device_class: 'energy',
      state_class: 'total_increasing',
      device: device,
      origin: origin,
    });

    // Sensor: Power Total
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'power_total', {
      object_id: `${this.name_}_power_total`,
      unique_id: `${this.name_}_power_total_p2m`,
      name: 'Power Total',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.PowerTotal }}',
      unit_of_measurement: 'W',
      device_class: 'power',
      state_class: 'measurement',
      device: device,
      origin: origin,
    });

    // For all three phases, create Current, Power and Voltage entries
    for (let phase = 1; phase <= this.phase_count_; ++phase) {
      // Sensor: Current
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'current_phase_' + phase,
        {
          object_id: `${this.name_}_current_phase_${phase}`,
          unique_id: `${this.name_}_current_phase_${phase}_p2m`,
          name: 'Current Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.CurrentPhase' + phase + ' }}',
          unit_of_measurement: 'mA',
          device_class: 'current',
          state_class: 'measurement',
          device: device,
          origin: origin,
        }
      );
      // Sensor: Current
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'power_phase_' + phase,
        {
          object_id: `${this.name_}_power_phase_${phase}`,
          unique_id: `${this.name_}_power_phase_${phase}_p2m`,
          name: 'Power Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.PowerPhase' + phase + ' }}',
          unit_of_measurement: 'W',
          device_class: 'power',
          state_class: 'measurement',
          device: device,
          origin: origin,
        }
      );
      // Sensor: Voltage
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'voltage_phase_' + phase,
        {
          object_id: `${this.name_}_voltage_phase_${phase}`,
          unique_id: `${this.name_}_voltage_phase_${phase}_p2m`,
          name: 'Voltage Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.VoltagePhase' + phase + ' }}',
          unit_of_measurement: 'V',
          device_class: 'voltage',
          state_class: 'measurement',
          device: device,
          origin: origin,
        }
      );
    }

    // EV interface data
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'binary_sensor',
      'car_connected',
      {
        object_id: `${this.name_}_car_connected`,
        unique_id: `${this.name_}_car_connected_p2m`,
        name: 'Car is connected',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json._CarHasConnected }}',
        device_class: 'plug',
        enabled_by_default: true,
        icon: 'mdi:ev-plug-type2',
        force_update: true,
        device: device,
        origin: origin,
      }
    );
    // this.mqtt_.publishHomeAssistantDiscoveryConfig(
    //   'number',
    //   'current_limit_setpoint',
    //   {
    //     object_id: `${this.name_}_current_limit_setpoint`,
    //     unique_id: `${this.name_}_current_limit_setpoint_p2m`,
    //     name: 'Current Limit Setpoint',
    //     // availability_mode: 'all',
    //     state_topic: this.mqtt_.getFullDataTopicPath('ev'),
    //     value_template: '{{ value_json.ChargeCurrentLimit }}',
    //     unit_of_measurement: 'mA',
    //     device_class: 'current',
    //     // availability: availability,
    //     device: device,
    //     origin: origin,
    //   }
    // );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'current_limit_actual',
      {
        object_id: `${this.name_}_current_limit_actual`,
        unique_id: `${this.name_}_current_limit_actual_p2m`,
        name: 'Current Limit Actual',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.ChargeCurrentLimitActual }}',
        unit_of_measurement: 'mA',
        device_class: 'current',
        state_class: 'measurement',
        icon: 'mdi:car-speed-limiter',
        device: device,
        origin: origin,
      }
    );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'current_limit_source',
      {
        object_id: `${this.name_}_current_limit_source`,
        unique_id: `${this.name_}_current_limit_source_p2m`,
        name: 'Current Limit Source',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.ChargeCurrentLimitSource }}',
        icon: 'mdi:car-speed-limiter',
        device_class: 'enum',
        options: [
          'Charging cable',
          'High temperature',
          'Installation limit',
          'Dynamic load balancing',
          'Group load balancing',
          'Overcurrent protection',
          'Hardware limitation',
          'Power factor',
          'OCPP smart charging',
          'Phase imbalance',
          'Local scheduled charging',
          'Solar charging',
          'Current limiter',
          'Local REST API',
          'Local Modbus API',
          'External power limit',
          'Household power limit',
        ],
        device: device,
        origin: origin,
      }
    );
    // this.mqtt_.publishHomeAssistantDiscoveryConfig(
    //   'switch',
    //   'force_single_phase',
    //   {
    //     object_id: `${this.name_}_force_single_phase`,
    //     unique_id: `${this.name_}_force_single_phase_p2m`,
    //     name: 'Force Single Phase',
    //     // availability_mode: 'all',
    //     state_topic: this.mqtt_.getFullDataTopicPath('ev'),
    //     value_template: '{{ value_json.Force1Phase }}',
    //     device_class: 'switch',
    //     // availability: availability,
    //     device: device,
    //     origin: origin,
    //   }
    // );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'control_pilot_state',
      {
        object_id: `${this.name_}_control_pilot_state`,
        unique_id: `${this.name_}_control_pilot_state_p2m`,
        name: 'Control Pilot State',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.CpState }}',
        icon: 'mdi:ev-plug-type2',
        device_class: 'enum',
        options: [
          'State A',
          'State B',
          'State C',
          'State D',
          'State E',
          'State F',
          'Invalid',
          'Unknown',
        ],
        device: device,
        origin: origin,
      }
    );
  }

  async getSystemData(): Promise<void> {
    // Get system data
    const {data, error} = await this.client_.GET('/system');
    if (error) {
      console.error('Error getting system data:', error);
    } else {
      console.log(data);

      let additional_changes = false;
      if (data.PhaseCount) {
        const old_phase_count = this.phase_count_;
        this.phase_count_ = data.PhaseCount;
        if (old_phase_count !== this.phase_count_) {
          additional_changes = true;
        }
      }

      if (data.Force1PhaseAllowed !== undefined) {
        const old_allow_single_phase = this.allow_single_phase_;
        this.allow_single_phase_ = data.Force1PhaseAllowed;
        if (old_allow_single_phase !== this.allow_single_phase_) {
          additional_changes = true;
        }
      }

      // Update HA device info
      if (data.ProductSn) {
        this.device_info_.serialNumber = data.ProductSn;
      }
      if (data.ProductPn) {
        this.device_info_.model = data.ProductPn;
      }
      if (data.FirmwareVersion) {
        this.device_info_.sw_version = data.FirmwareVersion;
      }
      if (this.device_info_.has_changed || additional_changes) {
        // Publish updated HA entries
        this.publishHomeAssistantDeviceInfo();
      }

      this.mqtt_.publishData('system', JSON.stringify(data));
    }
    if (this.is_online_) {
      // Check again in 1 hour
      this.timer_system_update_ = setTimeout(
        this.getSystemData.bind(this),
        INTERVAL_CHECK_SYSTEM
      );
    }
  }

  async getMeterData(): Promise<void> {
    // Get meter data
    const {data, error} = await this.client_.GET('/meter');
    if (error) {
      console.error('Error getting meter data:', error);
    } else {
      console.log(data);
      this.mqtt_.publishData('meter', JSON.stringify(data));
    }
    if (this.is_online_) {
      this.timer_meter_update_ = setTimeout(
        this.getMeterData.bind(this),
        this.has_car_connected_
          ? INTERVAL_CHECK_METER_CHARGING
          : INTERVAL_CHECK_METER_IDLE
      );
    }
  }

  async getEvInterfaceData(): Promise<void> {
    // Get meter data
    const {data, error} = await this.client_.GET('/evinterface');
    if (error) {
      console.error('Error getting EV interface data:', error);
    } else {
      console.log(data);

      // Currently charging if CpState is either State B or State C
      const was_car_connected = this.has_car_connected_;
      this.has_car_connected_ =
        data.CpState === 'State B' ||
        data.CpState === 'State C' ||
        data.CpState === 'State D';
      if (!was_car_connected && this.has_car_connected_ && this.is_online_) {
        // Car connected, update meter data more frequently
        if (this.timer_meter_update_) {
          clearTimeout(this.timer_meter_update_);
        }
        this.getMeterData();
      }

      // Extend data with has_car_connected_ property
      const extendedData = {
        ...data,
        _CarHasConnected: this.has_car_connected_ ? 'ON' : 'OFF',
      };
      this.mqtt_.publishData('ev', JSON.stringify(extendedData));
    }
    if (this.is_online_) {
      this.timer_ev_interface_update_ = setTimeout(
        this.getEvInterfaceData.bind(this),
        this.has_car_connected_
          ? INTERVAL_CHECK_EV_INTERFACE_CHARGING
          : INTERVAL_CHECK_EV_INTERFACE_IDLE
      );
    }
  }
}
