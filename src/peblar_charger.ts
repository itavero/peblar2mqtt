/* eslint-disable @typescript-eslint/no-floating-promises */
import createClient, {MiddlewareOnRequest, type Client} from 'openapi-fetch';
import type {paths} from './generated/api/v1'; // generated by openapi-typescript
import {getVersion} from './util/version';
import {StateMachine, t, FsmContext, IStateMachine} from '@fsmoothy/core';
import {isEqual} from 'lodash';

// Constants for "dynamic" timer intervals
const INTERVAL_CHECK_HEALTH_OFFLINE = 1000 * 10; // 10 seconds
const INTERVAL_CHECK_EV_INTERFACE_AND_METER = 1000 * 10; // 10 seconds

// Product name lookup table (based on product number)
interface ProductTypeInfo {
  name: string;
  max_amps: number;
  cable_length: number;
}

const PRODUCT_TYPE_INFO_LOOKUP: Record<string, ProductTypeInfo> = {
  '6004-2300-8002': {name: 'Peblar Home', max_amps: 16, cable_length: 5},
  '6004-2300-4502': {name: 'Peblar Home', max_amps: 16, cable_length: 7.5},
  '6004-2300-8103': {name: 'Peblar Home Plus', max_amps: 32, cable_length: 5},
  '6004-2300-4603': {name: 'Peblar Home Plus', max_amps: 32, cable_length: 7.5},
  '6004-2303-8700': {name: 'Peblar Business', max_amps: 32, cable_length: 7.5},
};
const FALLBACK_PRODUCT_PN = '6004-2300-8002';

interface SystemInfo {
  ProductPn?: string;
  ProductSn?: string;
  FirmwareVersion?: string;
  WlanSignalStrength?: number;
  CellularSignalStrength?: number;
  Uptime?: number;
  PhaseCount?: number;
  Force1PhaseAllowed?: boolean;
  ActiveErrorCodes?: unknown[];
  ActiveWarningCodes?: unknown[];
}

interface EvInterface {
  CpState?: string;
  LockState?: boolean;
  ChargeCurrentLimit?: number;
  ChargeCurrentLimitSource?: string;
  ChargeCurrentLimitActual?: number;
  Force1Phase?: boolean;
}

// Availability constants
const AVAILABLE_ONLINE = 'online';
const AVAILABLE_OFFLINE = 'offline';

class ApiTokenMiddleware {
  private token_: string;

  constructor(token: string) {
    this.token_ = token;
  }

  onRequest: MiddlewareOnRequest = ({request}) => {
    const headers = new Headers(request.headers);
    headers.set('Authorization', this.token_);
    return new Request(request, {headers});
  };
}

export interface MqttEndpoint {
  publishData(subject: string, data: string, retain?: boolean): void;
  publishHomeAssistantDiscoveryConfig(
    type: string,
    name: string,
    config: unknown,
  ): void;
  getFullDataTopicPath(subject: string): string;
  getBridgeAvailabilityTopicPath(): string;
}

class HomeAssistantDeviceInfo {
  private identifiers_: Set<string>;
  private readonly manufacturer_: string;
  private model_: string;
  private readonly name_: string;
  private sw_version_: string;
  private serial_number_: string;
  private did_change_ = false;

  constructor(
    identifiers: string[],
    manufacturer: string,
    model: string,
    name: string,
    sw_version?: string,
    serial_number?: string,
  ) {
    this.identifiers_ = new Set(identifiers);
    this.manufacturer_ = manufacturer;
    this.model_ = model;
    this.name_ = name;
    this.sw_version_ = sw_version ?? '';
    this.serial_number_ = serial_number ?? '';
  }

  equals(other: HomeAssistantDeviceInfo): boolean {
    return (
      this.manufacturer_ === other.manufacturer_ &&
      this.model_ === other.model_ &&
      this.name_ === other.name_ &&
      this.sw_version_ === other.sw_version_ &&
      this.identifiers_.size === other.identifiers_.size &&
      Array.from(this.identifiers_).every(id => other.identifiers_.has(id))
    );
  }

  get identifiers(): string[] {
    return Array.from(this.identifiers_);
  }

  get manufacturer(): string {
    return this.manufacturer_;
  }

  set serialNumber(serial_number: string) {
    if (this.serial_number_ !== serial_number) {
      this.serial_number_ = serial_number;
      this.identifiers_.add(serial_number);
      this.did_change_ = true;
    }
  }

  get model(): string {
    return this.model_;
  }

  set model(model: string) {
    if (this.model_ !== model) {
      this.model_ = model;
      this.did_change_ = true;
    }
  }

  get name(): string {
    return this.name_;
  }

  get sw_version(): string {
    return this.sw_version_;
  }

  set sw_version(sw_version: string) {
    if (this.sw_version_ !== sw_version) {
      this.sw_version_ = sw_version;
      this.did_change_ = true;
    }
  }

  get has_changed(): boolean {
    return this.did_change_;
  }

  addIdentifier(identifier: string): void {
    if (!this.identifiers_.has(identifier)) {
      this.identifiers_.add(identifier);
      this.did_change_ = true;
    }
  }

  resetChangeFlag(): void {
    this.did_change_ = false;
  }

  toPlainObject(): Record<string, unknown> {
    return {
      identifiers: this.identifiers,
      manufacturer: this.manufacturer_,
      model: this.model_,
      name: this.name_,
      sw_version: this.sw_version_,
    };
  }
}

enum ChargerMonitorState {
  checkHealth = 'checkHealth',
  getSystemInfo = 'getSystemInfo',
  chargerOnline = 'chargerOnline',
  shutdown = 'shutdown',
  waitOffline = 'waitOffline',
  stopped = 'stopped',
}

enum ChargerMonitorEvent {
  requestFailed = 'requestFailed',
  healthOk = 'healthOk',
  systemInfoUpdated = 'systemInfoUpdated',
  shutdownRequested = 'shutdownRequested',
  offlinePublished = 'offlinePublished',
  timerElapsed = 'timerElapsed',
  monitorStarted = 'monitorStarted',
}

enum ChargeDataState {
  inactive = 'inactive',
  requestEvInterface = 'requestEvInterface',
  requestMeter = 'requestMeter',
  waitForNextChargeDataUpdate = 'waitForNextChargeDataUpdate',
}

enum ChargeDataEvent {
  activate = 'activate',
  deactivate = 'deactivate',
  chargeDataTimerElapsed = 'chargeDataTimerElapsed',
  requestSucceeded = 'requestSucceeded',
  requestFailed = 'requestFailed',
}

type ChargeDataContext = FsmContext<{
  is_car_connected: boolean;
}>;

export class ChargerMonitor {
  private mqtt_: MqttEndpoint;
  private name_: string;
  private host_: string;
  private password_: string | undefined;
  private client_: Client<paths>;

  // Timers
  private timer_wait_offline: NodeJS.Timeout | undefined;
  private timer_charge_data: NodeJS.Timeout | undefined;

  // State machines
  private fsm_main_: IStateMachine<
    ChargerMonitorState,
    ChargerMonitorEvent,
    never
  >;
  // Since I could not get the nested state machine to work properly,
  // I just have a "parallel" state machine that I manually connect to the main state machine.
  private fsm_charge_data_: IStateMachine<
    ChargeDataState,
    ChargeDataEvent,
    ChargeDataContext
  >;

  // Charger information
  private api_version_ = '0';
  private api_can_write_ = false;
  private system_info_: SystemInfo = {};
  private product_info_: ProductTypeInfo =
    PRODUCT_TYPE_INFO_LOOKUP[FALLBACK_PRODUCT_PN];
  private ev_interface_: EvInterface = {};

  constructor(
    mqtt: MqttEndpoint,
    name: string,
    host: string,
    api_key: string,
    password?: string,
  ) {
    this.mqtt_ = mqtt;
    this.name_ = name;
    this.host_ = host;
    this.password_ = password;

    // Create REST API client from generated Open API models
    this.client_ = createClient<paths>({
      baseUrl: `http://${this.host_}/api/wlac/v1`,
    });
    this.client_.use(new ApiTokenMiddleware(api_key));

    // Create FSM
    this.fsm_main_ = new StateMachine<
      ChargerMonitorState,
      ChargerMonitorEvent,
      never
    >({
      id: 'monitor',
      initial: ChargerMonitorState.waitOffline,
      transitions: [
        t(
          [
            ChargerMonitorState.checkHealth,
            ChargerMonitorState.getSystemInfo,
            ChargerMonitorState.chargerOnline,
          ],
          ChargerMonitorEvent.requestFailed,
          ChargerMonitorState.waitOffline,
          {
            onEnter: this.startWaitOfflineTimer.bind(this),
          },
        ),
        t(
          ChargerMonitorState.waitOffline,
          ChargerMonitorEvent.timerElapsed,
          ChargerMonitorState.checkHealth,
          {
            onEnter: this.performHealthCheck.bind(this),
          },
        ),
        t(
          [ChargerMonitorState.waitOffline, ChargerMonitorState.stopped],
          ChargerMonitorEvent.monitorStarted,
          ChargerMonitorState.checkHealth,
          {
            onEnter: this.performHealthCheck.bind(this),
          },
        ),
        t(
          ChargerMonitorState.checkHealth,
          ChargerMonitorEvent.healthOk,
          ChargerMonitorState.getSystemInfo,
          {
            onEnter: this.requestSystemInfo.bind(this),
          },
        ),
        t(
          ChargerMonitorState.getSystemInfo,
          ChargerMonitorEvent.systemInfoUpdated,
          ChargerMonitorState.chargerOnline,
          {
            onEnter: this.onlineStateEntered.bind(this),
            onLeave: this.onlineStateBeingLeft.bind(this),
          },
        ),
        t(
          [
            ChargerMonitorState.chargerOnline,
            ChargerMonitorState.getSystemInfo,
            ChargerMonitorState.waitOffline,
            ChargerMonitorState.checkHealth,
          ],
          ChargerMonitorEvent.shutdownRequested,
          ChargerMonitorState.shutdown,
          {
            onEnter: this.stopAndGoOffline.bind(this),
          },
        ),
        t(
          ChargerMonitorState.shutdown,
          ChargerMonitorEvent.offlinePublished,
          ChargerMonitorState.stopped,
        ),
      ],
    });

    // Charge data state machine
    this.fsm_charge_data_ = new StateMachine<
      ChargeDataState,
      ChargeDataEvent,
      ChargeDataContext
    >({
      id: 'charge_data',
      initial: ChargeDataState.inactive,
      transitions: [
        t(
          ChargeDataState.inactive,
          ChargeDataEvent.activate,
          ChargeDataState.requestEvInterface,
          {
            onEnter: this.requestEvInterfaceData.bind(this),
          },
        ),
        t(
          ChargeDataState.waitForNextChargeDataUpdate,
          ChargeDataEvent.chargeDataTimerElapsed,
          ChargeDataState.requestEvInterface,
          {
            onEnter: this.requestEvInterfaceData.bind(this),
          },
        ),
        t(
          [
            ChargeDataState.requestEvInterface,
            ChargeDataState.requestMeter,
            ChargeDataState.waitForNextChargeDataUpdate,
          ],
          ChargeDataEvent.deactivate,
          ChargeDataState.inactive,
          {
            onEnter: () => {
              if (this.timer_charge_data) {
                clearTimeout(this.timer_charge_data);
                this.timer_charge_data = undefined;
              }
            },
          },
        ),
        t(
          ChargeDataState.requestEvInterface,
          ChargeDataEvent.requestSucceeded,
          ChargeDataState.requestMeter,
          {
            onEnter: this.requestMeterData.bind(this),
          },
        ),
        t(
          ChargeDataState.requestMeter,
          ChargeDataEvent.requestSucceeded,
          ChargeDataState.waitForNextChargeDataUpdate,
          {
            onEnter: this.startChargeDataTimer.bind(this),
          },
        ),
      ],
    });

    // If request fails in charge data state machine, request failed in main state machine
    this.fsm_charge_data_.on(ChargeDataEvent.requestFailed, async () => {
      await this.fsm_main_.requestFailed();
    });
  }

  get name(): string {
    return this.name_;
  }

  async start(): Promise<void> {
    if (await this.fsm_main_.can(ChargerMonitorEvent.monitorStarted)) {
      await this.fsm_main_.monitorStarted();
    }
  }

  async stop(): Promise<void> {
    if (await this.fsm_main_.can(ChargerMonitorEvent.shutdownRequested)) {
      await this.fsm_main_.shutdownRequested();
    }
  }

  private startWaitOfflineTimer(): void {
    if (this.timer_wait_offline) {
      clearTimeout(this.timer_wait_offline);
      this.timer_wait_offline = undefined;
    }
    this.timer_wait_offline = setTimeout(async () => {
      if (await this.fsm_main_.can(ChargerMonitorEvent.timerElapsed)) {
        await this.fsm_main_.timerElapsed();
      }
    }, INTERVAL_CHECK_HEALTH_OFFLINE);
  }

  private startChargeDataTimer(): void {
    if (this.timer_charge_data) {
      clearTimeout(this.timer_charge_data);
      this.timer_charge_data = undefined;
    }
    this.timer_charge_data = setTimeout(async () => {
      if (
        await this.fsm_charge_data_.can(ChargeDataEvent.chargeDataTimerElapsed)
      ) {
        await this.fsm_charge_data_.chargeDataTimerElapsed();
      }
    }, INTERVAL_CHECK_EV_INTERFACE_AND_METER);
  }

  private async performHealthCheck(): Promise<void> {
    // First publish offline status
    this.mqtt_.publishData('available', AVAILABLE_OFFLINE, true);

    // Check if the charger is online
    const {data, error} = await this.client_.GET('/health');
    if (error || data === undefined) {
      // Reset information
      this.api_version_ = '0';
      this.api_can_write_ = false;

      // Log failure
      console.error(`[${this.name_}] Error checking health: ${error}`);

      // Note: figure out why things no longer work if calls like the next are awaited.
      this.fsm_main_.requestFailed();
      return;
    }

    // Store information
    this.api_version_ = data.ApiVersion ?? '0';
    this.api_can_write_ = data.AccessMode === 'ReadWrite';

    // Check API version is compatible with v1.0 using SemVer
    if (!this.api_version_.startsWith('1.')) {
      console.error(
        `[${this.name_}] Expected API version compatible with v1.0, but got API version ${this.api_version_}`,
      );

      // Note: figure out why things no longer work if calls like the next are awaited.
      this.fsm_main_.requestFailed();
      return;
    }

    // Health check succeeded
    console.log(
      `[${this.name_}] Health: OK (API v${this.api_version_}; ${this.api_can_write_ ? 'read/write' : 'read-only'})`,
    );

    // Note: figure out why things no longer work if calls like the next are awaited.
    if (await this.fsm_main_.can(ChargerMonitorEvent.healthOk)) {
      await this.fsm_main_.healthOk();
    }
  }

  private async requestSystemInfo(): Promise<void> {
    const {data, error} = await this.client_.GET('/system');
    if (error || data === undefined) {
      console.error(`[${this.name_}] Error getting system data: ${error}`);

      // Note: figure out why things no longer work if calls like the next are awaited.
      this.fsm_main_.requestFailed();
    } else {
      this.system_info_ = data;

      // Log warning if phase count or product number is not set
      if (!data.PhaseCount) {
        console.warn(`[${this.name_}] Phase count is not set in system data.`);
      }

      // Check if ProductPn is found in lookup table
      if (data.ProductPn && data.ProductPn in PRODUCT_TYPE_INFO_LOOKUP) {
        this.product_info_ = PRODUCT_TYPE_INFO_LOOKUP[data.ProductPn];
      } else {
        console.warn(
          `[${this.name_}] Product number (${data.ProductPn ?? 'not provided'}) not found in lookup table. Using fallback product number (${FALLBACK_PRODUCT_PN}).`,
        );
        this.product_info_ = PRODUCT_TYPE_INFO_LOOKUP[FALLBACK_PRODUCT_PN];
      }

      this.mqtt_.publishData('system', JSON.stringify(data), true);

      // Note: figure out why things no longer work if calls like the next are awaited.
      this.fsm_main_.systemInfoUpdated();
    }
  }

  private async stopAndGoOffline(): Promise<void> {
    console.log(`[${this.name_}] Stopping monitor...`);
    // Stop all timers
    if (this.timer_wait_offline) {
      clearTimeout(this.timer_wait_offline);
      this.timer_wait_offline = undefined;
    }
    if (this.timer_charge_data) {
      clearTimeout(this.timer_charge_data);
      this.timer_charge_data = undefined;
    }

    // Publish offline status
    try {
      this.mqtt_.publishData('available', AVAILABLE_OFFLINE, true);
    } catch (e) {
      // Log warning and fail silently otherwise
      console.warn(`[${this.name_}] Error publishing offline status: ${e}`);
    }

    // Note: figure out why things no longer work if calls like the next are awaited.
    this.fsm_main_.offlinePublished();
  }

  private async onlineStateEntered(): Promise<void> {
    console.log(
      `[${this.name_}] Charger is online! (${this.product_info_.name})`,
    );

    // Publish online status
    this.mqtt_.publishData('available', AVAILABLE_ONLINE, true);

    // Publish HA device info
    await this.publishHomeAssistantDeviceInfo();

    // Immediately request EV interface data
    if (await this.fsm_charge_data_.can(ChargeDataEvent.activate)) {
      await this.fsm_charge_data_.activate();
    }
  }

  private async onlineStateBeingLeft(): Promise<void> {
    await this.fsm_charge_data_.deactivate();
  }

  private async publishHomeAssistantDeviceInfo(): Promise<void> {
    let product_name = this.product_info_.name;
    if (this.product_info_.cable_length > 0) {
      product_name += ` (${this.product_info_.cable_length}m)`;
    }
    const device_info = new HomeAssistantDeviceInfo(
      [this.name_],
      'Peblar',
      product_name,
      this.name_,
      this.system_info_.FirmwareVersion ?? '',
    );
    if (this.system_info_.ProductSn) {
      device_info.serialNumber = this.system_info_.ProductSn;
    }
    const device = device_info.toPlainObject();
    const origin = {
      name: 'Peblar2MQTT',
      sw_version: getVersion(),
      support_url: 'https://github.com/itavero/peblar2mqtt',
    };
    const availability = [
      {
        topic: this.mqtt_.getBridgeAvailabilityTopicPath(),
      },
      {
        topic: this.mqtt_.getFullDataTopicPath('available'),
      },
    ];

    // Sensor: Energy Total
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'energy_total', {
      object_id: `${this.name_}_energy_total`,
      unique_id: `${this.name_}_energy_total_p2m`,
      name: 'Energy Total',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.EnergyTotal }}',
      unit_of_measurement: 'Wh',
      device_class: 'energy',
      state_class: 'total_increasing',
      device: device,
      origin: origin,
    });

    // Sensor: Energy Session
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'energy_session', {
      object_id: `${this.name_}_energy_session`,
      unique_id: `${this.name_}_energy_session_p2m`,
      name: 'Energy Session',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.EnergySession }}',
      unit_of_measurement: 'Wh',
      device_class: 'energy',
      state_class: 'total_increasing',
      device: device,
      origin: origin,
    });

    // Sensor: Power Total
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'power_total', {
      object_id: `${this.name_}_power_total`,
      unique_id: `${this.name_}_power_total_p2m`,
      name: 'Power Total',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.PowerTotal }}',
      unit_of_measurement: 'W',
      device_class: 'power',
      state_class: 'measurement',
      device: device,
      origin: origin,
    });

    // For all three phases, create Current, Power and Voltage entries
    const phase_count = this.system_info_.PhaseCount ?? 1;
    for (let phase = 1; phase <= phase_count; ++phase) {
      // Sensor: Current
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'current_phase_' + phase,
        {
          object_id: `${this.name_}_current_phase_${phase}`,
          unique_id: `${this.name_}_current_phase_${phase}_p2m`,
          name: 'Current Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.CurrentPhase' + phase + ' }}',
          unit_of_measurement: 'mA',
          device_class: 'current',
          state_class: 'measurement',
          device: device,
          origin: origin,
        },
      );
      // Sensor: Current
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'power_phase_' + phase,
        {
          object_id: `${this.name_}_power_phase_${phase}`,
          unique_id: `${this.name_}_power_phase_${phase}_p2m`,
          name: 'Power Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.PowerPhase' + phase + ' }}',
          unit_of_measurement: 'W',
          device_class: 'power',
          state_class: 'measurement',
          device: device,
          origin: origin,
        },
      );
      // Sensor: Voltage
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'voltage_phase_' + phase,
        {
          object_id: `${this.name_}_voltage_phase_${phase}`,
          unique_id: `${this.name_}_voltage_phase_${phase}_p2m`,
          name: 'Voltage Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.VoltagePhase' + phase + ' }}',
          unit_of_measurement: 'V',
          device_class: 'voltage',
          state_class: 'measurement',
          device: device,
          origin: origin,
        },
      );
    }

    // EV interface data
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'binary_sensor',
      'car_connected',
      {
        object_id: `${this.name_}_car_connected`,
        unique_id: `${this.name_}_car_connected_p2m`,
        name: 'Car is connected',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json._CarHasConnected }}',
        device_class: 'plug',
        enabled_by_default: true,
        icon: 'mdi:ev-plug-type2',
        force_update: true,
        device: device,
        origin: origin,
      },
    );
    // this.mqtt_.publishHomeAssistantDiscoveryConfig(
    //   'number',
    //   'current_limit_setpoint',
    //   {
    //     object_id: `${this.name_}_current_limit_setpoint`,
    //     unique_id: `${this.name_}_current_limit_setpoint_p2m`,
    //     name: 'Current Limit Setpoint',
    //     // availability_mode: 'all',
    //     state_topic: this.mqtt_.getFullDataTopicPath('ev'),
    //     value_template: '{{ value_json.ChargeCurrentLimit }}',
    //     unit_of_measurement: 'mA',
    //     device_class: 'current',
    //     // availability: availability,
    //     device: device,
    //     origin: origin,
    //   }
    // );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'current_limit_actual',
      {
        object_id: `${this.name_}_current_limit_actual`,
        unique_id: `${this.name_}_current_limit_actual_p2m`,
        name: 'Current Limit Actual',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.ChargeCurrentLimitActual }}',
        unit_of_measurement: 'mA',
        device_class: 'current',
        state_class: 'measurement',
        icon: 'mdi:car-speed-limiter',
        device: device,
        origin: origin,
      },
    );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'current_limit_source',
      {
        object_id: `${this.name_}_current_limit_source`,
        unique_id: `${this.name_}_current_limit_source_p2m`,
        name: 'Current Limit Source',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.ChargeCurrentLimitSource }}',
        icon: 'mdi:car-speed-limiter',
        device_class: 'enum',
        options: [
          'Charging cable',
          'High temperature',
          'Installation limit',
          'Dynamic load balancing',
          'Group load balancing',
          'Overcurrent protection',
          'Hardware limitation',
          'Power factor',
          'OCPP smart charging',
          'Phase imbalance',
          'Local scheduled charging',
          'Solar charging',
          'Current limiter',
          'Local REST API',
          'Local Modbus API',
          'External power limit',
          'Household power limit',
        ],
        device: device,
        origin: origin,
      },
    );
    // this.mqtt_.publishHomeAssistantDiscoveryConfig(
    //   'switch',
    //   'force_single_phase',
    //   {
    //     object_id: `${this.name_}_force_single_phase`,
    //     unique_id: `${this.name_}_force_single_phase_p2m`,
    //     name: 'Force Single Phase',
    //     // availability_mode: 'all',
    //     state_topic: this.mqtt_.getFullDataTopicPath('ev'),
    //     value_template: '{{ value_json.Force1Phase }}',
    //     device_class: 'switch',
    //     // availability: availability,
    //     device: device,
    //     origin: origin,
    //   }
    // );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'control_pilot_state',
      {
        object_id: `${this.name_}_control_pilot_state`,
        unique_id: `${this.name_}_control_pilot_state_p2m`,
        name: 'Control Pilot State',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.CpState }}',
        icon: 'mdi:ev-plug-type2',
        device_class: 'enum',
        options: [
          'State A',
          'State B',
          'State C',
          'State D',
          'State E',
          'State F',
          'Invalid',
          'Unknown',
        ],
        device: device,
        origin: origin,
      },
    );
  }

  private async requestEvInterfaceData(
    context: ChargeDataContext,
  ): Promise<void> {
    const {data, error} = await this.client_.GET('/evinterface');
    if (error || data === undefined) {
      console.error(
        `[${this.name_}] Error getting EV interface data: ${error}`,
      );

      // Note: figure out why things no longer work if calls like the next are awaited.
      this.fsm_charge_data_.requestFailed();
    } else {
      // Currently connected if CpState is either State B, State C or State D
      const was_car_connected = context.data.is_car_connected ?? false;
      context.data.is_car_connected =
        data.CpState === 'State B' ||
        data.CpState === 'State C' ||
        data.CpState === 'State D';

      if (was_car_connected !== context.data.is_car_connected) {
        console.log(
          `[${this.name_}] Car ${was_car_connected ? 'disconnected' : 'connected'}`,
        );
      }

      // Only publish if data has changed
      if (!isEqual(this.ev_interface_, data)) {
        // Extend data with has_car_connected_ property
        const extendedData = {
          ...data,
          _CarHasConnected: context.data.is_car_connected ? 'ON' : 'OFF',
        };
        this.mqtt_.publishData('ev', JSON.stringify(extendedData), true);
      }
      this.ev_interface_ = data;

      // Note: figure out why things no longer work if calls like the next are awaited.
      this.fsm_charge_data_.requestSucceeded();
    }
  }

  private async requestMeterData(): Promise<void> {
    const {data, error} = await this.client_.GET('/meter');
    if (error) {
      console.error(`[${this.name_}] Error getting meter data: ${error}`);

      // Note: figure out why things no longer work if calls like the next are awaited.
      this.fsm_charge_data_.requestFailed();
    } else {
      this.mqtt_.publishData('meter', JSON.stringify(data));

      // Note: figure out why things no longer work if calls like the next are awaited.
      this.fsm_charge_data_.requestSucceeded();
    }
  }
}
