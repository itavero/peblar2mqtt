import createClient, {MiddlewareOnRequest, type Client} from 'openapi-fetch';
import type {paths} from './generated/api/v1'; // generated by openapi-typescript
import {getVersion} from './util/version';
import {StateMachine, t, FsmContext, IStateMachine} from '@fsmoothy/core';
import {isEqual} from 'lodash';

// Constants for "dynamic" timer intervals
const INTERVAL_CHECK_HEALTH_OFFLINE = 1000 * 10; // 10 seconds
const INTERVAL_CHECK_EV_INTERFACE_AND_METER = 1000 * 10; // 10 seconds

// Constants related to preventing frequent relay switching
/**
 * Minimum value the current limit can be set to in order to turn on the relay.
 */
const MINIMUM_CURRENT_LIMIT_TO_TURN_ON = 6000; // 6 A

/**
 * Minimum time the relay should be in the same state before it can be switched again.
 * This is to prevent very frequent relay switching.
 *
 * This should be considered more as an additional fail-safe, as the algorithm used
 * to control the current limit should also prevent frequent relay switching.
 */
const MINIMUM_RELAY_PERIOD = 1000 * 60; // 60 seconds

/**
 * Grace period applied after a change in the current limit or force single phase is received.
 * Data for these two properties may not come in the same request, so we need to wait a bit to be sure.
 */
const CURRENT_LIMIT_GRACE_PERIOD = 1000 * 10; // 10 seconds

// Product name lookup table (based on product number)
interface ProductTypeInfo {
  name: string;
  max_amps: number;
  cable_length: number;
}

const PRODUCT_TYPE_INFO_LOOKUP: Record<string, ProductTypeInfo> = {
  '6004-2300-8002': {name: 'Peblar Home', max_amps: 16, cable_length: 5},
  '6004-2300-4502': {name: 'Peblar Home', max_amps: 16, cable_length: 7.5},
  '6004-2300-8103': {name: 'Peblar Home Plus', max_amps: 32, cable_length: 5},
  '6004-2300-4603': {name: 'Peblar Home Plus', max_amps: 32, cable_length: 7.5},
  '6004-2303-8700': {name: 'Peblar Business', max_amps: 32, cable_length: 7.5},
};
const FALLBACK_PRODUCT_PN = '6004-2300-8002';

interface SystemInfo {
  ProductPn?: string;
  ProductSn?: string;
  FirmwareVersion?: string;
  WlanSignalStrength?: number;
  CellularSignalStrength?: number;
  Uptime?: number;
  PhaseCount?: number;
  Force1PhaseAllowed?: boolean;
  ActiveErrorCodes?: unknown[];
  ActiveWarningCodes?: unknown[];
}

interface EvInterface {
  CpState?: string;
  LockState?: boolean;
  ChargeCurrentLimit?: number;
  ChargeCurrentLimitSource?: string;
  ChargeCurrentLimitActual?: number;
  Force1Phase?: boolean;
}

// Availability constants
const AVAILABLE_ONLINE = 'online';
const AVAILABLE_OFFLINE = 'offline';

class ApiTokenMiddleware {
  private token_: string;

  constructor(token: string) {
    this.token_ = token;
  }

  onRequest: MiddlewareOnRequest = ({request}) => {
    const headers = new Headers(request.headers);
    headers.set('Authorization', this.token_);
    return new Request(request, {headers});
  };
}

export interface MqttEndpoint {
  publishData(subject: string, data: string, retain?: boolean): void;
  publishHomeAssistantDiscoveryConfig(
    type: string,
    name: string,
    config: unknown
  ): void;
  getFullDataTopicPath(subject: string): string;
  getBridgeAvailabilityTopicPath(): string;
}

class HomeAssistantDeviceInfo {
  private identifiers_: Set<string>;
  private readonly manufacturer_: string;
  private model_: string;
  private readonly name_: string;
  private sw_version_: string;
  private serial_number_: string;
  private did_change_ = false;

  constructor(
    identifiers: string[],
    manufacturer: string,
    model: string,
    name: string,
    sw_version?: string,
    serial_number?: string
  ) {
    this.identifiers_ = new Set(identifiers);
    this.manufacturer_ = manufacturer;
    this.model_ = model;
    this.name_ = name;
    this.sw_version_ = sw_version ?? '';
    this.serial_number_ = serial_number ?? '';
  }

  equals(other: HomeAssistantDeviceInfo): boolean {
    return (
      this.manufacturer_ === other.manufacturer_ &&
      this.model_ === other.model_ &&
      this.name_ === other.name_ &&
      this.sw_version_ === other.sw_version_ &&
      this.identifiers_.size === other.identifiers_.size &&
      Array.from(this.identifiers_).every(id => other.identifiers_.has(id))
    );
  }

  get identifiers(): string[] {
    return Array.from(this.identifiers_);
  }

  get manufacturer(): string {
    return this.manufacturer_;
  }

  set serialNumber(serial_number: string) {
    if (this.serial_number_ !== serial_number) {
      this.serial_number_ = serial_number;
      this.identifiers_.add(serial_number);
      this.did_change_ = true;
    }
  }

  get model(): string {
    return this.model_;
  }

  set model(model: string) {
    if (this.model_ !== model) {
      this.model_ = model;
      this.did_change_ = true;
    }
  }

  get name(): string {
    return this.name_;
  }

  get sw_version(): string {
    return this.sw_version_;
  }

  set sw_version(sw_version: string) {
    if (this.sw_version_ !== sw_version) {
      this.sw_version_ = sw_version;
      this.did_change_ = true;
    }
  }

  get has_changed(): boolean {
    return this.did_change_;
  }

  addIdentifier(identifier: string): void {
    if (!this.identifiers_.has(identifier)) {
      this.identifiers_.add(identifier);
      this.did_change_ = true;
    }
  }

  resetChangeFlag(): void {
    this.did_change_ = false;
  }

  toPlainObject(): Record<string, unknown> {
    return {
      identifiers: this.identifiers,
      manufacturer: this.manufacturer_,
      model: this.model_,
      name: this.name_,
      sw_version: this.sw_version_,
    };
  }
}

enum ChargerMonitorState {
  checkHealth = 'checkHealth',
  getSystemInfo = 'getSystemInfo',
  chargerOnline = 'chargerOnline',
  shutdown = 'shutdown',
  waitOffline = 'waitOffline',
  stopped = 'stopped',
}

enum ChargerMonitorEvent {
  requestFailed = 'requestFailed',
  healthOk = 'healthOk',
  systemInfoUpdated = 'systemInfoUpdated',
  shutdownRequested = 'shutdownRequested',
  offlinePublished = 'offlinePublished',
  timerElapsed = 'timerElapsed',
  monitorStarted = 'monitorStarted',
}

enum ChargeDataState {
  inactive = 'inactive',
  requestEvInterface = 'requestEvInterface',
  requestMeter = 'requestMeter',
  waitForNextChargeDataUpdate = 'waitForNextChargeDataUpdate',
}

enum ChargeDataEvent {
  activate = 'activate',
  deactivate = 'deactivate',
  chargeDataTimerElapsed = 'chargeDataTimerElapsed',
  requestSucceeded = 'requestSucceeded',
  requestFailed = 'requestFailed',
}

type ChargeDataContext = FsmContext<{
  is_car_connected: boolean;
}>;

enum CurrentLimiterState {
  idle = 'idle',
  gracePeriod = 'gracePeriod',
  waitForRelayPeriod = 'waitForRelayPeriod',
  doRequest = 'doRequest',
}

enum CurrentLimiterEvent {
  requestReceived = 'requestReceived',
  gracePeriodElapsed = 'gracePeriodElapsed',
  relayPeriodElapsed = 'relayPeriodElapsed',
  requestSucceeded = 'requestSucceeded',
  requestFailed = 'requestFailed',
}

type CurrentLimiterContext = FsmContext<{
  timer: NodeJS.Timeout | undefined;
  requested_force_single_phase: boolean | undefined;
  requested_current_limit: number | undefined;
  expected_to_switch_main_relay: boolean;
  expected_to_switch_phase_relay: boolean;
  last_phase_relay_switch: Date | undefined;
  last_main_relay_switch: Date | undefined;
}>;

export class ChargerMonitor {
  private mqtt_: MqttEndpoint;
  private name_: string;
  private host_: string;
  private password_: string | undefined;
  private client_: Client<paths>;

  // Timers
  private timer_wait_offline: NodeJS.Timeout | undefined;
  private timer_charge_data: NodeJS.Timeout | undefined;

  // State machines
  private fsm_main_: IStateMachine<
    ChargerMonitorState,
    ChargerMonitorEvent,
    never
  >;
  // Since I could not get the nested state machine to work properly,
  // I just have a "parallel" state machine that I manually connect to the main state machine.
  private fsm_charge_data_: IStateMachine<
    ChargeDataState,
    ChargeDataEvent,
    ChargeDataContext
  >;
  private fsm_current_limiter_: IStateMachine<
    CurrentLimiterState,
    CurrentLimiterEvent,
    CurrentLimiterContext
  >;

  // Charger information
  private api_version_ = '0';
  private api_can_write_ = false;
  private system_info_: SystemInfo = {};
  private product_info_: ProductTypeInfo =
    PRODUCT_TYPE_INFO_LOOKUP[FALLBACK_PRODUCT_PN];
  private ev_interface_: EvInterface = {};

  constructor(
    mqtt: MqttEndpoint,
    name: string,
    host: string,
    api_key: string,
    password?: string
  ) {
    this.mqtt_ = mqtt;
    this.name_ = name;
    this.host_ = host;
    this.password_ = password;

    // Create REST API client from generated Open API models
    this.client_ = createClient<paths>({
      baseUrl: `http://${this.host_}/api/wlac/v1`,
    });
    this.client_.use(new ApiTokenMiddleware(api_key));

    // Create FSM
    this.fsm_main_ = new StateMachine<
      ChargerMonitorState,
      ChargerMonitorEvent,
      never
    >({
      id: 'monitor',
      initial: ChargerMonitorState.waitOffline,
      transitions: [
        t(
          [
            ChargerMonitorState.checkHealth,
            ChargerMonitorState.getSystemInfo,
            ChargerMonitorState.chargerOnline,
          ],
          ChargerMonitorEvent.requestFailed,
          ChargerMonitorState.waitOffline,
          {
            onEnter: this.startWaitOfflineTimer.bind(this),
          }
        ),
        t(
          ChargerMonitorState.waitOffline,
          ChargerMonitorEvent.timerElapsed,
          ChargerMonitorState.checkHealth,
          {
            onEnter: this.performHealthCheck.bind(this),
          }
        ),
        t(
          [ChargerMonitorState.waitOffline, ChargerMonitorState.stopped],
          ChargerMonitorEvent.monitorStarted,
          ChargerMonitorState.checkHealth,
          {
            onEnter: this.performHealthCheck.bind(this),
          }
        ),
        t(
          ChargerMonitorState.checkHealth,
          ChargerMonitorEvent.healthOk,
          ChargerMonitorState.getSystemInfo,
          {
            onEnter: this.requestSystemInfo.bind(this),
          }
        ),
        t(
          ChargerMonitorState.getSystemInfo,
          ChargerMonitorEvent.systemInfoUpdated,
          ChargerMonitorState.chargerOnline,
          {
            onEnter: this.onlineStateEntered.bind(this),
            onLeave: this.onlineStateBeingLeft.bind(this),
          }
        ),
        t(
          [
            ChargerMonitorState.chargerOnline,
            ChargerMonitorState.getSystemInfo,
            ChargerMonitorState.waitOffline,
            ChargerMonitorState.checkHealth,
          ],
          ChargerMonitorEvent.shutdownRequested,
          ChargerMonitorState.shutdown,
          {
            onEnter: this.stopAndGoOffline.bind(this),
          }
        ),
        t(
          ChargerMonitorState.shutdown,
          ChargerMonitorEvent.offlinePublished,
          ChargerMonitorState.stopped
        ),
      ],
    });

    // Charge data state machine
    this.fsm_charge_data_ = new StateMachine<
      ChargeDataState,
      ChargeDataEvent,
      ChargeDataContext
    >({
      id: 'charge_data',
      initial: ChargeDataState.inactive,
      transitions: [
        t(
          ChargeDataState.inactive,
          ChargeDataEvent.activate,
          ChargeDataState.requestEvInterface,
          {
            onEnter: this.requestEvInterfaceData.bind(this),
          }
        ),
        t(
          ChargeDataState.waitForNextChargeDataUpdate,
          ChargeDataEvent.chargeDataTimerElapsed,
          ChargeDataState.requestEvInterface,
          {
            onEnter: this.requestEvInterfaceData.bind(this),
          }
        ),
        t(
          [
            ChargeDataState.requestEvInterface,
            ChargeDataState.requestMeter,
            ChargeDataState.waitForNextChargeDataUpdate,
          ],
          ChargeDataEvent.deactivate,
          ChargeDataState.inactive,
          {
            onEnter: () => {
              if (this.timer_charge_data) {
                clearTimeout(this.timer_charge_data);
                this.timer_charge_data = undefined;
              }
            },
          }
        ),
        t(
          ChargeDataState.requestEvInterface,
          ChargeDataEvent.requestSucceeded,
          ChargeDataState.requestMeter,
          {
            onEnter: this.requestMeterData.bind(this),
          }
        ),
        t(
          ChargeDataState.requestMeter,
          ChargeDataEvent.requestSucceeded,
          ChargeDataState.waitForNextChargeDataUpdate,
          {
            onEnter: this.startChargeDataTimer.bind(this),
          }
        ),
        t(
          [ChargeDataState.requestEvInterface, ChargeDataState.requestMeter],
          ChargeDataEvent.requestFailed,
          ChargeDataState.inactive
        ),
      ],
    });

    // Current limiter state machine
    this.fsm_current_limiter_ = new StateMachine<
      CurrentLimiterState,
      CurrentLimiterEvent,
      CurrentLimiterContext
    >({
      id: 'current_limiter',
      initial: CurrentLimiterState.idle,
      transitions: [
        t(
          [CurrentLimiterState.idle, CurrentLimiterState.gracePeriod],
          CurrentLimiterEvent.requestReceived,
          CurrentLimiterState.gracePeriod,
          {
            guard(
              context,
              current_limit: number,
              force_single_phase: boolean
            ): boolean {
              // Check if one of the requested values has changed
              return (
                context.data.requested_current_limit !== current_limit ||
                context.data.requested_force_single_phase !== force_single_phase
              );
            },
            onEnter: (
              context,
              current_limit: number,
              force_single_phase: boolean
            ) => {
              const previous_requested_current_limit =
                context.data.requested_current_limit;
              const previous_requested_force_single_phase =
                context.data.requested_force_single_phase;

              context.data.requested_current_limit = current_limit;
              context.data.requested_force_single_phase = force_single_phase;

              // Check if the main relay is expected to switch (e.g. goes from below threshold to above or vice versa)
              let expected_to_switch_main_relay = false;
              let expect_main_to_turn_on = false;
              if (current_limit !== undefined) {
                const previous_limit =
                  this.ev_interface_.ChargeCurrentLimit ??
                  previous_requested_current_limit;
                if (previous_limit === undefined) {
                  expected_to_switch_main_relay = true;
                } else {
                  const previous_main_relay_on =
                    previous_limit >= MINIMUM_CURRENT_LIMIT_TO_TURN_ON;
                  expect_main_to_turn_on =
                    current_limit >= MINIMUM_CURRENT_LIMIT_TO_TURN_ON;
                  expected_to_switch_main_relay =
                    previous_main_relay_on !== expect_main_to_turn_on;
                }
              }

              // Check if the phase relay is expected to switch
              let expected_to_switch_phase_relay = false;
              if ((this.system_info_.PhaseCount ?? 3) > 1) {
                const previous_force_state =
                  this.ev_interface_.Force1Phase ??
                  previous_requested_force_single_phase;
                if (previous_force_state === undefined) {
                  expected_to_switch_phase_relay = true;
                } else {
                  if (!previous_force_state && !expect_main_to_turn_on) {
                    // was allowing 3 phase, but current limit is now below threshold, which will also turn off the phase relay
                    expected_to_switch_phase_relay = true;
                  } else {
                    expected_to_switch_phase_relay =
                      previous_force_state !== force_single_phase;
                  }
                }
              }

              context.data.expected_to_switch_main_relay =
                expected_to_switch_main_relay;
              context.data.expected_to_switch_phase_relay =
                expected_to_switch_phase_relay;

              // If one of the relay dates is undefined, set it to current time
              if (context.data.last_main_relay_switch === undefined) {
                context.data.last_main_relay_switch = new Date();
              }
              if (context.data.last_phase_relay_switch === undefined) {
                context.data.last_phase_relay_switch = new Date();
              }

              if (this.timer_charge_data) {
                clearTimeout(this.timer_charge_data);
                this.timer_charge_data = undefined;
              }
              this.timer_charge_data = setTimeout(async () => {
                await this.fsm_current_limiter_.gracePeriodElapsed();
              }, CURRENT_LIMIT_GRACE_PERIOD);
            },
          }
        ),
        t(
          CurrentLimiterState.gracePeriod,
          CurrentLimiterEvent.gracePeriodElapsed,
          CurrentLimiterState.waitForRelayPeriod,
          {
            onEnter: context => {
              // If we assume a relay change, we need to calculate the relay period
              let wait_until = new Date();
              if (context.data.expected_to_switch_main_relay) {
                if (context.data.last_main_relay_switch) {
                  wait_until = new Date(
                    context.data.last_main_relay_switch.getTime() +
                      MINIMUM_RELAY_PERIOD
                  );
                } else {
                  wait_until.setTime(
                    wait_until.getTime() + MINIMUM_RELAY_PERIOD
                  );
                }
                if (context.data.expected_to_switch_phase_relay) {
                  let alternative_time = new Date();
                  if (context.data.last_phase_relay_switch) {
                    alternative_time = new Date(
                      context.data.last_phase_relay_switch.getTime() +
                        MINIMUM_RELAY_PERIOD
                    );
                  } else {
                    alternative_time.setTime(
                      alternative_time.getTime() + MINIMUM_RELAY_PERIOD
                    );
                  }
                  if (alternative_time > wait_until) {
                    wait_until = alternative_time;
                  }
                }

                // Is wait until in the past?
                if (wait_until < new Date()) {
                  // No need to wait, we can proceed immediately
                  this.fsm_current_limiter_.relayPeriodElapsed();
                } else {
                  // Wait until the calculated time
                  if (context.data.timer) {
                    clearTimeout(context.data.timer);
                    context.data.timer = undefined;
                  }
                  context.data.timer = setTimeout(async () => {
                    await this.fsm_current_limiter_.relayPeriodElapsed();
                  }, wait_until.getTime() - new Date().getTime());
                }
              }
            },
          }
        ),
        t(
          CurrentLimiterState.waitForRelayPeriod,
          CurrentLimiterEvent.relayPeriodElapsed,
          CurrentLimiterState.doRequest,
          {
            onEnter: async context => {
              const {data, error} = await this.client_.PATCH('/evinterface', {
                body: {
                  ChargeCurrentLimit: context.data.requested_current_limit,
                  Force1Phase: context.data.requested_force_single_phase,
                },
              });

              if (error) {
                console.error(
                  `[${this.name_}] Error setting current limit/single phase: ${error}`
                );
                await this.fsm_current_limiter_.requestFailed();
              } else {
                console.log(
                  `[${this.name_}] Current limit set successfully: ${data}`
                );

                // Clear requested values
                context.data.requested_current_limit = undefined;
                context.data.requested_force_single_phase = undefined;
                await this.fsm_current_limiter_.requestSucceeded();
              }
            },
          }
        ),
        t(
          CurrentLimiterState.doRequest,
          CurrentLimiterEvent.requestSucceeded,
          CurrentLimiterState.idle
        ),
        t(
          CurrentLimiterState.doRequest,
          CurrentLimiterEvent.requestFailed,
          CurrentLimiterState.idle
        ),
      ],
    });

    // If request fails in charge data or current limiter state machine, request failed in main state machine
    this.fsm_charge_data_.on(ChargeDataEvent.requestFailed, () => {
      this.fsm_main_.requestFailed();
    });
    this.fsm_current_limiter_.on(CurrentLimiterEvent.requestFailed, () => {
      this.fsm_main_.requestFailed();
    });
  }

  get name(): string {
    return this.name_;
  }

  async start(): Promise<void> {
    if (await this.fsm_main_.can(ChargerMonitorEvent.monitorStarted)) {
      await this.fsm_main_.monitorStarted();
    }
  }

  async stop(): Promise<void> {
    if (await this.fsm_main_.can(ChargerMonitorEvent.shutdownRequested)) {
      await this.fsm_main_.shutdownRequested();
    }
  }

  private startWaitOfflineTimer(): void {
    if (this.timer_wait_offline) {
      clearTimeout(this.timer_wait_offline);
      this.timer_wait_offline = undefined;
    }
    this.timer_wait_offline = setTimeout(() => {
      this.fsm_main_.timerElapsed();
    }, INTERVAL_CHECK_HEALTH_OFFLINE);
  }

  private startChargeDataTimer(): void {
    if (this.timer_charge_data) {
      clearTimeout(this.timer_charge_data);
      this.timer_charge_data = undefined;
    }
    this.timer_charge_data = setTimeout(async () => {
      await this.fsm_charge_data_.chargeDataTimerElapsed();
    }, INTERVAL_CHECK_EV_INTERFACE_AND_METER);
  }

  private async performHealthCheck(): Promise<void> {
    // First publish offline status
    this.mqtt_.publishData('available', AVAILABLE_OFFLINE, true);

    // Check if the charger is online
    const {data, error} = await this.client_.GET('/health');
    if (error) {
      // Reset information
      this.api_version_ = '0';
      this.api_can_write_ = false;

      // Log failure
      console.error(`[${this.name_}] Error checking health: ${error}`);

      this.fsm_main_.requestFailed();
      return;
    }

    // Store information
    this.api_version_ = data.ApiVersion ?? '0';
    this.api_can_write_ = data.AccessMode === 'ReadWrite';

    // Check API version is compatible with v1.0 using SemVer
    if (!this.api_version_.startsWith('1.')) {
      console.error(
        `[${this.name_}] Expected API version compatible with v1.0, but got API version ${this.api_version_}`
      );
      this.fsm_main_.requestFailed();
      return;
    }

    // Health check succeeded
    console.log(
      `[${this.name_}] Health: OK (API v${this.api_version_}; ${this.api_can_write_ ? 'read/write' : 'read-only'})`
    );
    this.fsm_main_.healthOk();
  }

  private async requestSystemInfo(): Promise<void> {
    const {data, error} = await this.client_.GET('/system');
    if (error) {
      console.error(`[${this.name_}] Error getting system data: ${error}`);
      this.fsm_main_.requestFailed();
    } else {
      this.system_info_ = data;

      // Log warning if phase count or product number is not set
      if (!data.PhaseCount) {
        console.warn(`[${this.name_}] Phase count is not set in system data.`);
      }

      // Check if ProductPn is found in lookup table
      if (data.ProductPn && data.ProductPn in PRODUCT_TYPE_INFO_LOOKUP) {
        this.product_info_ = PRODUCT_TYPE_INFO_LOOKUP[data.ProductPn];
      } else {
        console.warn(
          `[${this.name_}] Product number (${data.ProductPn ?? 'not provided'}) not found in lookup table. Using fallback product number (${FALLBACK_PRODUCT_PN}).`
        );
        this.product_info_ = PRODUCT_TYPE_INFO_LOOKUP[FALLBACK_PRODUCT_PN];
      }

      this.mqtt_.publishData('system', JSON.stringify(data), true);
      this.fsm_main_.systemInfoUpdated();
    }
  }

  private async stopAndGoOffline(): Promise<void> {
    console.log(`[${this.name_}] Stopping monitor...`);
    // Stop all timers
    if (this.timer_wait_offline) {
      clearTimeout(this.timer_wait_offline);
      this.timer_wait_offline = undefined;
    }
    if (this.timer_charge_data) {
      clearTimeout(this.timer_charge_data);
      this.timer_charge_data = undefined;
    }

    // Publish offline status
    try {
      this.mqtt_.publishData('available', AVAILABLE_OFFLINE, true);
    } catch (e) {
      // Log warning and fail silently otherwise
      console.warn(`[${this.name_}] Error publishing offline status: ${e}`);
    }
    this.fsm_main_.offlinePublished();
  }

  private async onlineStateEntered(): Promise<void> {
    console.log(
      `[${this.name_}] Charger is online! (${this.product_info_.name})`
    );

    // Publish online status
    this.mqtt_.publishData('available', AVAILABLE_ONLINE, true);

    // Publish HA device info
    this.publishHomeAssistantDeviceInfo();

    // Immediately request EV interface data
    if (await this.fsm_charge_data_.can(ChargeDataEvent.activate)) {
      await this.fsm_charge_data_.activate();
    }
  }

  private async onlineStateBeingLeft(): Promise<void> {
    await this.fsm_charge_data_.deactivate();
  }

  private async publishHomeAssistantDeviceInfo(): Promise<void> {
    let product_name = this.product_info_.name;
    if (this.product_info_.cable_length > 0) {
      product_name += ` (${this.product_info_.cable_length}m)`;
    }
    const device_info = new HomeAssistantDeviceInfo(
      [this.name_],
      'Peblar',
      product_name,
      this.name_,
      this.system_info_.FirmwareVersion ?? ''
    );
    if (this.system_info_.ProductSn) {
      device_info.serialNumber = this.system_info_.ProductSn;
    }
    const device = device_info.toPlainObject();
    const origin = {
      name: 'Peblar2MQTT',
      sw_version: getVersion(),
      support_url: 'https://github.com/itavero/peblar2mqtt',
    };
    const availability = [
      {
        topic: this.mqtt_.getBridgeAvailabilityTopicPath(),
      },
      {
        topic: this.mqtt_.getFullDataTopicPath('available'),
      },
    ];

    // Sensor: Energy Total
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'energy_total', {
      object_id: `${this.name_}_energy_total`,
      unique_id: `${this.name_}_energy_total_p2m`,
      name: 'Energy Total',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.EnergyTotal }}',
      unit_of_measurement: 'Wh',
      device_class: 'energy',
      state_class: 'total_increasing',
      device: device,
      origin: origin,
    });

    // Sensor: Energy Session
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'energy_session', {
      object_id: `${this.name_}_energy_session`,
      unique_id: `${this.name_}_energy_session_p2m`,
      name: 'Energy Session',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.EnergySession }}',
      unit_of_measurement: 'Wh',
      device_class: 'energy',
      state_class: 'total_increasing',
      device: device,
      origin: origin,
    });

    // Sensor: Power Total
    this.mqtt_.publishHomeAssistantDiscoveryConfig('sensor', 'power_total', {
      object_id: `${this.name_}_power_total`,
      unique_id: `${this.name_}_power_total_p2m`,
      name: 'Power Total',
      availability: availability,
      availability_mode: 'all',
      state_topic: this.mqtt_.getFullDataTopicPath('meter'),
      value_template: '{{ value_json.PowerTotal }}',
      unit_of_measurement: 'W',
      device_class: 'power',
      state_class: 'measurement',
      device: device,
      origin: origin,
    });

    // For all three phases, create Current, Power and Voltage entries
    const phase_count = this.system_info_.PhaseCount ?? 1;
    for (let phase = 1; phase <= phase_count; ++phase) {
      // Sensor: Current
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'current_phase_' + phase,
        {
          object_id: `${this.name_}_current_phase_${phase}`,
          unique_id: `${this.name_}_current_phase_${phase}_p2m`,
          name: 'Current Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.CurrentPhase' + phase + ' }}',
          unit_of_measurement: 'mA',
          device_class: 'current',
          state_class: 'measurement',
          device: device,
          origin: origin,
        }
      );
      // Sensor: Current
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'power_phase_' + phase,
        {
          object_id: `${this.name_}_power_phase_${phase}`,
          unique_id: `${this.name_}_power_phase_${phase}_p2m`,
          name: 'Power Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.PowerPhase' + phase + ' }}',
          unit_of_measurement: 'W',
          device_class: 'power',
          state_class: 'measurement',
          device: device,
          origin: origin,
        }
      );
      // Sensor: Voltage
      this.mqtt_.publishHomeAssistantDiscoveryConfig(
        'sensor',
        'voltage_phase_' + phase,
        {
          object_id: `${this.name_}_voltage_phase_${phase}`,
          unique_id: `${this.name_}_voltage_phase_${phase}_p2m`,
          name: 'Voltage Phase ' + phase,
          availability: availability,
          availability_mode: 'all',
          state_topic: this.mqtt_.getFullDataTopicPath('meter'),
          value_template: '{{ value_json.VoltagePhase' + phase + ' }}',
          unit_of_measurement: 'V',
          device_class: 'voltage',
          state_class: 'measurement',
          device: device,
          origin: origin,
        }
      );
    }

    // EV interface data
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'binary_sensor',
      'car_connected',
      {
        object_id: `${this.name_}_car_connected`,
        unique_id: `${this.name_}_car_connected_p2m`,
        name: 'Car is connected',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json._CarHasConnected }}',
        device_class: 'plug',
        enabled_by_default: true,
        icon: 'mdi:ev-plug-type2',
        force_update: true,
        device: device,
        origin: origin,
      }
    );
    // this.mqtt_.publishHomeAssistantDiscoveryConfig(
    //   'number',
    //   'current_limit_setpoint',
    //   {
    //     object_id: `${this.name_}_current_limit_setpoint`,
    //     unique_id: `${this.name_}_current_limit_setpoint_p2m`,
    //     name: 'Current Limit Setpoint',
    //     // availability_mode: 'all',
    //     state_topic: this.mqtt_.getFullDataTopicPath('ev'),
    //     value_template: '{{ value_json.ChargeCurrentLimit }}',
    //     unit_of_measurement: 'mA',
    //     device_class: 'current',
    //     // availability: availability,
    //     device: device,
    //     origin: origin,
    //   }
    // );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'current_limit_actual',
      {
        object_id: `${this.name_}_current_limit_actual`,
        unique_id: `${this.name_}_current_limit_actual_p2m`,
        name: 'Current Limit Actual',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.ChargeCurrentLimitActual }}',
        unit_of_measurement: 'mA',
        device_class: 'current',
        state_class: 'measurement',
        icon: 'mdi:car-speed-limiter',
        device: device,
        origin: origin,
      }
    );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'current_limit_source',
      {
        object_id: `${this.name_}_current_limit_source`,
        unique_id: `${this.name_}_current_limit_source_p2m`,
        name: 'Current Limit Source',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.ChargeCurrentLimitSource }}',
        icon: 'mdi:car-speed-limiter',
        device_class: 'enum',
        options: [
          'Charging cable',
          'High temperature',
          'Installation limit',
          'Dynamic load balancing',
          'Group load balancing',
          'Overcurrent protection',
          'Hardware limitation',
          'Power factor',
          'OCPP smart charging',
          'Phase imbalance',
          'Local scheduled charging',
          'Solar charging',
          'Current limiter',
          'Local REST API',
          'Local Modbus API',
          'External power limit',
          'Household power limit',
        ],
        device: device,
        origin: origin,
      }
    );
    // this.mqtt_.publishHomeAssistantDiscoveryConfig(
    //   'switch',
    //   'force_single_phase',
    //   {
    //     object_id: `${this.name_}_force_single_phase`,
    //     unique_id: `${this.name_}_force_single_phase_p2m`,
    //     name: 'Force Single Phase',
    //     // availability_mode: 'all',
    //     state_topic: this.mqtt_.getFullDataTopicPath('ev'),
    //     value_template: '{{ value_json.Force1Phase }}',
    //     device_class: 'switch',
    //     // availability: availability,
    //     device: device,
    //     origin: origin,
    //   }
    // );
    this.mqtt_.publishHomeAssistantDiscoveryConfig(
      'sensor',
      'control_pilot_state',
      {
        object_id: `${this.name_}_control_pilot_state`,
        unique_id: `${this.name_}_control_pilot_state_p2m`,
        name: 'Control Pilot State',
        availability: availability,
        availability_mode: 'all',
        state_topic: this.mqtt_.getFullDataTopicPath('ev'),
        value_template: '{{ value_json.CpState }}',
        icon: 'mdi:ev-plug-type2',
        device_class: 'enum',
        options: [
          'State A',
          'State B',
          'State C',
          'State D',
          'State E',
          'State F',
          'Invalid',
          'Unknown',
        ],
        device: device,
        origin: origin,
      }
    );
  }

  private async requestEvInterfaceData(
    context: ChargeDataContext
  ): Promise<void> {
    const {data, error} = await this.client_.GET('/evinterface');
    if (error) {
      console.error(
        `[${this.name_}] Error getting EV interface data: ${error}`
      );
      this.fsm_charge_data_.requestFailed();
    } else {
      // Currently connected if CpState is either State B, State C or State D
      const was_car_connected = context.data.is_car_connected;
      context.data.is_car_connected =
        data.CpState === 'State B' ||
        data.CpState === 'State C' ||
        data.CpState === 'State D';

      if (was_car_connected !== context.data.is_car_connected) {
        console.log(
          `[${this.name_}] Car ${was_car_connected ? 'disconnected' : 'connected'}`
        );
      }

      // Only publish if data has changed
      if (!isEqual(this.ev_interface_, data)) {
        // Extend data with has_car_connected_ property
        const extendedData = {
          ...data,
          _CarHasConnected: context.data.is_car_connected ? 'ON' : 'OFF',
        };
        this.mqtt_.publishData('ev', JSON.stringify(extendedData), true);
      }
      this.ev_interface_ = data;

      this.fsm_charge_data_.requestSucceeded();
    }
  }

  private async requestMeterData(): Promise<void> {
    const {data, error} = await this.client_.GET('/meter');
    if (error) {
      console.error(`[${this.name_}] Error getting meter data: ${error}`);
      this.fsm_charge_data_.requestFailed();
    } else {
      this.mqtt_.publishData('meter', JSON.stringify(data));
      this.fsm_charge_data_.requestSucceeded();
    }
  }
}
